// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: amazon.proto

#ifndef PROTOBUF_amazon_2eproto__INCLUDED
#define PROTOBUF_amazon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_amazon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAProductImpl();
void InitDefaultsAProduct();
void InitDefaultsAInitWarehouseImpl();
void InitDefaultsAInitWarehouse();
void InitDefaultsAConnectImpl();
void InitDefaultsAConnect();
void InitDefaultsAConnectedImpl();
void InitDefaultsAConnected();
void InitDefaultsAPackImpl();
void InitDefaultsAPack();
void InitDefaultsAPutOnTruckImpl();
void InitDefaultsAPutOnTruck();
void InitDefaultsAPurchaseMoreImpl();
void InitDefaultsAPurchaseMore();
void InitDefaultsACommandsImpl();
void InitDefaultsACommands();
void InitDefaultsAResponsesImpl();
void InitDefaultsAResponses();
void InitDefaultsAWarehouseImpl();
void InitDefaultsAWarehouse();
void InitDefaultsUConnectAImpl();
void InitDefaultsUConnectA();
void InitDefaultsAConnectUImpl();
void InitDefaultsAConnectU();
void InitDefaultsAGoodInfoImpl();
void InitDefaultsAGoodInfo();
void InitDefaultsUTruckMatchImpl();
void InitDefaultsUTruckMatch();
void InitDefaultsUTruckInfoImpl();
void InitDefaultsUTruckInfo();
void InitDefaultsA2UResponsesImpl();
void InitDefaultsA2UResponses();
void InitDefaultsU2AResponsesImpl();
void InitDefaultsU2AResponses();
inline void InitDefaults() {
  InitDefaultsAProduct();
  InitDefaultsAInitWarehouse();
  InitDefaultsAConnect();
  InitDefaultsAConnected();
  InitDefaultsAPack();
  InitDefaultsAPutOnTruck();
  InitDefaultsAPurchaseMore();
  InitDefaultsACommands();
  InitDefaultsAResponses();
  InitDefaultsAWarehouse();
  InitDefaultsUConnectA();
  InitDefaultsAConnectU();
  InitDefaultsAGoodInfo();
  InitDefaultsUTruckMatch();
  InitDefaultsUTruckInfo();
  InitDefaultsA2UResponses();
  InitDefaultsU2AResponses();
}
}  // namespace protobuf_amazon_2eproto
class A2UResponses;
class A2UResponsesDefaultTypeInternal;
extern A2UResponsesDefaultTypeInternal _A2UResponses_default_instance_;
class ACommands;
class ACommandsDefaultTypeInternal;
extern ACommandsDefaultTypeInternal _ACommands_default_instance_;
class AConnect;
class AConnectDefaultTypeInternal;
extern AConnectDefaultTypeInternal _AConnect_default_instance_;
class AConnectU;
class AConnectUDefaultTypeInternal;
extern AConnectUDefaultTypeInternal _AConnectU_default_instance_;
class AConnected;
class AConnectedDefaultTypeInternal;
extern AConnectedDefaultTypeInternal _AConnected_default_instance_;
class AGoodInfo;
class AGoodInfoDefaultTypeInternal;
extern AGoodInfoDefaultTypeInternal _AGoodInfo_default_instance_;
class AInitWarehouse;
class AInitWarehouseDefaultTypeInternal;
extern AInitWarehouseDefaultTypeInternal _AInitWarehouse_default_instance_;
class APack;
class APackDefaultTypeInternal;
extern APackDefaultTypeInternal _APack_default_instance_;
class AProduct;
class AProductDefaultTypeInternal;
extern AProductDefaultTypeInternal _AProduct_default_instance_;
class APurchaseMore;
class APurchaseMoreDefaultTypeInternal;
extern APurchaseMoreDefaultTypeInternal _APurchaseMore_default_instance_;
class APutOnTruck;
class APutOnTruckDefaultTypeInternal;
extern APutOnTruckDefaultTypeInternal _APutOnTruck_default_instance_;
class AResponses;
class AResponsesDefaultTypeInternal;
extern AResponsesDefaultTypeInternal _AResponses_default_instance_;
class AWarehouse;
class AWarehouseDefaultTypeInternal;
extern AWarehouseDefaultTypeInternal _AWarehouse_default_instance_;
class U2AResponses;
class U2AResponsesDefaultTypeInternal;
extern U2AResponsesDefaultTypeInternal _U2AResponses_default_instance_;
class UConnectA;
class UConnectADefaultTypeInternal;
extern UConnectADefaultTypeInternal _UConnectA_default_instance_;
class UTruckInfo;
class UTruckInfoDefaultTypeInternal;
extern UTruckInfoDefaultTypeInternal _UTruckInfo_default_instance_;
class UTruckMatch;
class UTruckMatchDefaultTypeInternal;
extern UTruckMatchDefaultTypeInternal _UTruckMatch_default_instance_;

// ===================================================================

class AProduct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AProduct) */ {
 public:
  AProduct();
  virtual ~AProduct();

  AProduct(const AProduct& from);

  inline AProduct& operator=(const AProduct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AProduct(AProduct&& from) noexcept
    : AProduct() {
    *this = ::std::move(from);
  }

  inline AProduct& operator=(AProduct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AProduct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AProduct* internal_default_instance() {
    return reinterpret_cast<const AProduct*>(
               &_AProduct_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AProduct* other);
  friend void swap(AProduct& a, AProduct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AProduct* New() const PROTOBUF_FINAL { return New(NULL); }

  AProduct* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AProduct& from);
  void MergeFrom(const AProduct& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AProduct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // required int32 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AProduct)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_description();
  void clear_has_description();
  void set_has_count();
  void clear_has_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 count_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAProductImpl();
};
// -------------------------------------------------------------------

class AInitWarehouse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AInitWarehouse) */ {
 public:
  AInitWarehouse();
  virtual ~AInitWarehouse();

  AInitWarehouse(const AInitWarehouse& from);

  inline AInitWarehouse& operator=(const AInitWarehouse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AInitWarehouse(AInitWarehouse&& from) noexcept
    : AInitWarehouse() {
    *this = ::std::move(from);
  }

  inline AInitWarehouse& operator=(AInitWarehouse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AInitWarehouse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AInitWarehouse* internal_default_instance() {
    return reinterpret_cast<const AInitWarehouse*>(
               &_AInitWarehouse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AInitWarehouse* other);
  friend void swap(AInitWarehouse& a, AInitWarehouse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AInitWarehouse* New() const PROTOBUF_FINAL { return New(NULL); }

  AInitWarehouse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AInitWarehouse& from);
  void MergeFrom(const AInitWarehouse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AInitWarehouse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AInitWarehouse)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAInitWarehouseImpl();
};
// -------------------------------------------------------------------

class AConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AConnect) */ {
 public:
  AConnect();
  virtual ~AConnect();

  AConnect(const AConnect& from);

  inline AConnect& operator=(const AConnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AConnect(AConnect&& from) noexcept
    : AConnect() {
    *this = ::std::move(from);
  }

  inline AConnect& operator=(AConnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AConnect* internal_default_instance() {
    return reinterpret_cast<const AConnect*>(
               &_AConnect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AConnect* other);
  friend void swap(AConnect& a, AConnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AConnect* New() const PROTOBUF_FINAL { return New(NULL); }

  AConnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AConnect& from);
  void MergeFrom(const AConnect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AConnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AInitWarehouse initwh = 2;
  int initwh_size() const;
  void clear_initwh();
  static const int kInitwhFieldNumber = 2;
  const ::AInitWarehouse& initwh(int index) const;
  ::AInitWarehouse* mutable_initwh(int index);
  ::AInitWarehouse* add_initwh();
  ::google::protobuf::RepeatedPtrField< ::AInitWarehouse >*
      mutable_initwh();
  const ::google::protobuf::RepeatedPtrField< ::AInitWarehouse >&
      initwh() const;

  // required int64 worldid = 1;
  bool has_worldid() const;
  void clear_worldid();
  static const int kWorldidFieldNumber = 1;
  ::google::protobuf::int64 worldid() const;
  void set_worldid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AConnect)
 private:
  void set_has_worldid();
  void clear_has_worldid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AInitWarehouse > initwh_;
  ::google::protobuf::int64 worldid_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAConnectImpl();
};
// -------------------------------------------------------------------

class AConnected : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AConnected) */ {
 public:
  AConnected();
  virtual ~AConnected();

  AConnected(const AConnected& from);

  inline AConnected& operator=(const AConnected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AConnected(AConnected&& from) noexcept
    : AConnected() {
    *this = ::std::move(from);
  }

  inline AConnected& operator=(AConnected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AConnected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AConnected* internal_default_instance() {
    return reinterpret_cast<const AConnected*>(
               &_AConnected_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AConnected* other);
  friend void swap(AConnected& a, AConnected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AConnected* New() const PROTOBUF_FINAL { return New(NULL); }

  AConnected* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AConnected& from);
  void MergeFrom(const AConnected& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AConnected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:AConnected)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAConnectedImpl();
};
// -------------------------------------------------------------------

class APack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:APack) */ {
 public:
  APack();
  virtual ~APack();

  APack(const APack& from);

  inline APack& operator=(const APack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  APack(APack&& from) noexcept
    : APack() {
    *this = ::std::move(from);
  }

  inline APack& operator=(APack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const APack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const APack* internal_default_instance() {
    return reinterpret_cast<const APack*>(
               &_APack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(APack* other);
  friend void swap(APack& a, APack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline APack* New() const PROTOBUF_FINAL { return New(NULL); }

  APack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const APack& from);
  void MergeFrom(const APack& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(APack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AProduct things = 2;
  int things_size() const;
  void clear_things();
  static const int kThingsFieldNumber = 2;
  const ::AProduct& things(int index) const;
  ::AProduct* mutable_things(int index);
  ::AProduct* add_things();
  ::google::protobuf::RepeatedPtrField< ::AProduct >*
      mutable_things();
  const ::google::protobuf::RepeatedPtrField< ::AProduct >&
      things() const;

  // required int64 shipid = 3;
  bool has_shipid() const;
  void clear_shipid();
  static const int kShipidFieldNumber = 3;
  ::google::protobuf::int64 shipid() const;
  void set_shipid(::google::protobuf::int64 value);

  // required int32 whnum = 1;
  bool has_whnum() const;
  void clear_whnum();
  static const int kWhnumFieldNumber = 1;
  ::google::protobuf::int32 whnum() const;
  void set_whnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:APack)
 private:
  void set_has_whnum();
  void clear_has_whnum();
  void set_has_shipid();
  void clear_has_shipid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AProduct > things_;
  ::google::protobuf::int64 shipid_;
  ::google::protobuf::int32 whnum_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAPackImpl();
};
// -------------------------------------------------------------------

class APutOnTruck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:APutOnTruck) */ {
 public:
  APutOnTruck();
  virtual ~APutOnTruck();

  APutOnTruck(const APutOnTruck& from);

  inline APutOnTruck& operator=(const APutOnTruck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  APutOnTruck(APutOnTruck&& from) noexcept
    : APutOnTruck() {
    *this = ::std::move(from);
  }

  inline APutOnTruck& operator=(APutOnTruck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const APutOnTruck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const APutOnTruck* internal_default_instance() {
    return reinterpret_cast<const APutOnTruck*>(
               &_APutOnTruck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(APutOnTruck* other);
  friend void swap(APutOnTruck& a, APutOnTruck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline APutOnTruck* New() const PROTOBUF_FINAL { return New(NULL); }

  APutOnTruck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const APutOnTruck& from);
  void MergeFrom(const APutOnTruck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(APutOnTruck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 whnum = 1;
  bool has_whnum() const;
  void clear_whnum();
  static const int kWhnumFieldNumber = 1;
  ::google::protobuf::int32 whnum() const;
  void set_whnum(::google::protobuf::int32 value);

  // required int32 truckid = 2;
  bool has_truckid() const;
  void clear_truckid();
  static const int kTruckidFieldNumber = 2;
  ::google::protobuf::int32 truckid() const;
  void set_truckid(::google::protobuf::int32 value);

  // required int64 shipid = 3;
  bool has_shipid() const;
  void clear_shipid();
  static const int kShipidFieldNumber = 3;
  ::google::protobuf::int64 shipid() const;
  void set_shipid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:APutOnTruck)
 private:
  void set_has_whnum();
  void clear_has_whnum();
  void set_has_truckid();
  void clear_has_truckid();
  void set_has_shipid();
  void clear_has_shipid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 whnum_;
  ::google::protobuf::int32 truckid_;
  ::google::protobuf::int64 shipid_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAPutOnTruckImpl();
};
// -------------------------------------------------------------------

class APurchaseMore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:APurchaseMore) */ {
 public:
  APurchaseMore();
  virtual ~APurchaseMore();

  APurchaseMore(const APurchaseMore& from);

  inline APurchaseMore& operator=(const APurchaseMore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  APurchaseMore(APurchaseMore&& from) noexcept
    : APurchaseMore() {
    *this = ::std::move(from);
  }

  inline APurchaseMore& operator=(APurchaseMore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const APurchaseMore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const APurchaseMore* internal_default_instance() {
    return reinterpret_cast<const APurchaseMore*>(
               &_APurchaseMore_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(APurchaseMore* other);
  friend void swap(APurchaseMore& a, APurchaseMore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline APurchaseMore* New() const PROTOBUF_FINAL { return New(NULL); }

  APurchaseMore* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const APurchaseMore& from);
  void MergeFrom(const APurchaseMore& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(APurchaseMore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AProduct things = 2;
  int things_size() const;
  void clear_things();
  static const int kThingsFieldNumber = 2;
  const ::AProduct& things(int index) const;
  ::AProduct* mutable_things(int index);
  ::AProduct* add_things();
  ::google::protobuf::RepeatedPtrField< ::AProduct >*
      mutable_things();
  const ::google::protobuf::RepeatedPtrField< ::AProduct >&
      things() const;

  // required int32 whnum = 1;
  bool has_whnum() const;
  void clear_whnum();
  static const int kWhnumFieldNumber = 1;
  ::google::protobuf::int32 whnum() const;
  void set_whnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:APurchaseMore)
 private:
  void set_has_whnum();
  void clear_has_whnum();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AProduct > things_;
  ::google::protobuf::int32 whnum_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAPurchaseMoreImpl();
};
// -------------------------------------------------------------------

class ACommands : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ACommands) */ {
 public:
  ACommands();
  virtual ~ACommands();

  ACommands(const ACommands& from);

  inline ACommands& operator=(const ACommands& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACommands(ACommands&& from) noexcept
    : ACommands() {
    *this = ::std::move(from);
  }

  inline ACommands& operator=(ACommands&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACommands& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACommands* internal_default_instance() {
    return reinterpret_cast<const ACommands*>(
               &_ACommands_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ACommands* other);
  friend void swap(ACommands& a, ACommands& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACommands* New() const PROTOBUF_FINAL { return New(NULL); }

  ACommands* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ACommands& from);
  void MergeFrom(const ACommands& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ACommands* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .APurchaseMore buy = 1;
  int buy_size() const;
  void clear_buy();
  static const int kBuyFieldNumber = 1;
  const ::APurchaseMore& buy(int index) const;
  ::APurchaseMore* mutable_buy(int index);
  ::APurchaseMore* add_buy();
  ::google::protobuf::RepeatedPtrField< ::APurchaseMore >*
      mutable_buy();
  const ::google::protobuf::RepeatedPtrField< ::APurchaseMore >&
      buy() const;

  // repeated .APutOnTruck load = 2;
  int load_size() const;
  void clear_load();
  static const int kLoadFieldNumber = 2;
  const ::APutOnTruck& load(int index) const;
  ::APutOnTruck* mutable_load(int index);
  ::APutOnTruck* add_load();
  ::google::protobuf::RepeatedPtrField< ::APutOnTruck >*
      mutable_load();
  const ::google::protobuf::RepeatedPtrField< ::APutOnTruck >&
      load() const;

  // repeated .APack topack = 3;
  int topack_size() const;
  void clear_topack();
  static const int kTopackFieldNumber = 3;
  const ::APack& topack(int index) const;
  ::APack* mutable_topack(int index);
  ::APack* add_topack();
  ::google::protobuf::RepeatedPtrField< ::APack >*
      mutable_topack();
  const ::google::protobuf::RepeatedPtrField< ::APack >&
      topack() const;

  // optional uint32 simspeed = 4;
  bool has_simspeed() const;
  void clear_simspeed();
  static const int kSimspeedFieldNumber = 4;
  ::google::protobuf::uint32 simspeed() const;
  void set_simspeed(::google::protobuf::uint32 value);

  // optional bool disconnect = 5;
  bool has_disconnect() const;
  void clear_disconnect();
  static const int kDisconnectFieldNumber = 5;
  bool disconnect() const;
  void set_disconnect(bool value);

  // @@protoc_insertion_point(class_scope:ACommands)
 private:
  void set_has_simspeed();
  void clear_has_simspeed();
  void set_has_disconnect();
  void clear_has_disconnect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::APurchaseMore > buy_;
  ::google::protobuf::RepeatedPtrField< ::APutOnTruck > load_;
  ::google::protobuf::RepeatedPtrField< ::APack > topack_;
  ::google::protobuf::uint32 simspeed_;
  bool disconnect_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsACommandsImpl();
};
// -------------------------------------------------------------------

class AResponses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AResponses) */ {
 public:
  AResponses();
  virtual ~AResponses();

  AResponses(const AResponses& from);

  inline AResponses& operator=(const AResponses& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AResponses(AResponses&& from) noexcept
    : AResponses() {
    *this = ::std::move(from);
  }

  inline AResponses& operator=(AResponses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AResponses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AResponses* internal_default_instance() {
    return reinterpret_cast<const AResponses*>(
               &_AResponses_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(AResponses* other);
  friend void swap(AResponses& a, AResponses& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AResponses* New() const PROTOBUF_FINAL { return New(NULL); }

  AResponses* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AResponses& from);
  void MergeFrom(const AResponses& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AResponses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .APurchaseMore arrived = 1;
  int arrived_size() const;
  void clear_arrived();
  static const int kArrivedFieldNumber = 1;
  const ::APurchaseMore& arrived(int index) const;
  ::APurchaseMore* mutable_arrived(int index);
  ::APurchaseMore* add_arrived();
  ::google::protobuf::RepeatedPtrField< ::APurchaseMore >*
      mutable_arrived();
  const ::google::protobuf::RepeatedPtrField< ::APurchaseMore >&
      arrived() const;

  // repeated int64 ready = 2;
  int ready_size() const;
  void clear_ready();
  static const int kReadyFieldNumber = 2;
  ::google::protobuf::int64 ready(int index) const;
  void set_ready(int index, ::google::protobuf::int64 value);
  void add_ready(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      ready() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_ready();

  // repeated int64 loaded = 3;
  int loaded_size() const;
  void clear_loaded();
  static const int kLoadedFieldNumber = 3;
  ::google::protobuf::int64 loaded(int index) const;
  void set_loaded(int index, ::google::protobuf::int64 value);
  void add_loaded(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      loaded() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_loaded();

  // optional string error = 4;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 4;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // optional bool finished = 5;
  bool has_finished() const;
  void clear_finished();
  static const int kFinishedFieldNumber = 5;
  bool finished() const;
  void set_finished(bool value);

  // @@protoc_insertion_point(class_scope:AResponses)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_finished();
  void clear_has_finished();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::APurchaseMore > arrived_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > ready_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > loaded_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  bool finished_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAResponsesImpl();
};
// -------------------------------------------------------------------

class AWarehouse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AWarehouse) */ {
 public:
  AWarehouse();
  virtual ~AWarehouse();

  AWarehouse(const AWarehouse& from);

  inline AWarehouse& operator=(const AWarehouse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AWarehouse(AWarehouse&& from) noexcept
    : AWarehouse() {
    *this = ::std::move(from);
  }

  inline AWarehouse& operator=(AWarehouse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AWarehouse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AWarehouse* internal_default_instance() {
    return reinterpret_cast<const AWarehouse*>(
               &_AWarehouse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(AWarehouse* other);
  friend void swap(AWarehouse& a, AWarehouse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AWarehouse* New() const PROTOBUF_FINAL { return New(NULL); }

  AWarehouse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AWarehouse& from);
  void MergeFrom(const AWarehouse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AWarehouse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 wid = 1;
  bool has_wid() const;
  void clear_wid();
  static const int kWidFieldNumber = 1;
  ::google::protobuf::int32 wid() const;
  void set_wid(::google::protobuf::int32 value);

  // required int32 x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AWarehouse)
 private:
  void set_has_wid();
  void clear_has_wid();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 wid_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAWarehouseImpl();
};
// -------------------------------------------------------------------

class UConnectA : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UConnectA) */ {
 public:
  UConnectA();
  virtual ~UConnectA();

  UConnectA(const UConnectA& from);

  inline UConnectA& operator=(const UConnectA& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UConnectA(UConnectA&& from) noexcept
    : UConnectA() {
    *this = ::std::move(from);
  }

  inline UConnectA& operator=(UConnectA&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UConnectA& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UConnectA* internal_default_instance() {
    return reinterpret_cast<const UConnectA*>(
               &_UConnectA_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(UConnectA* other);
  friend void swap(UConnectA& a, UConnectA& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UConnectA* New() const PROTOBUF_FINAL { return New(NULL); }

  UConnectA* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UConnectA& from);
  void MergeFrom(const UConnectA& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UConnectA* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 worldid = 1;
  bool has_worldid() const;
  void clear_worldid();
  static const int kWorldidFieldNumber = 1;
  ::google::protobuf::int64 worldid() const;
  void set_worldid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UConnectA)
 private:
  void set_has_worldid();
  void clear_has_worldid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 worldid_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsUConnectAImpl();
};
// -------------------------------------------------------------------

class AConnectU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AConnectU) */ {
 public:
  AConnectU();
  virtual ~AConnectU();

  AConnectU(const AConnectU& from);

  inline AConnectU& operator=(const AConnectU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AConnectU(AConnectU&& from) noexcept
    : AConnectU() {
    *this = ::std::move(from);
  }

  inline AConnectU& operator=(AConnectU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AConnectU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AConnectU* internal_default_instance() {
    return reinterpret_cast<const AConnectU*>(
               &_AConnectU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(AConnectU* other);
  friend void swap(AConnectU& a, AConnectU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AConnectU* New() const PROTOBUF_FINAL { return New(NULL); }

  AConnectU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AConnectU& from);
  void MergeFrom(const AConnectU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AConnectU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AWarehouse initwh = 1;
  int initwh_size() const;
  void clear_initwh();
  static const int kInitwhFieldNumber = 1;
  const ::AWarehouse& initwh(int index) const;
  ::AWarehouse* mutable_initwh(int index);
  ::AWarehouse* add_initwh();
  ::google::protobuf::RepeatedPtrField< ::AWarehouse >*
      mutable_initwh();
  const ::google::protobuf::RepeatedPtrField< ::AWarehouse >&
      initwh() const;

  // optional string error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:AConnectU)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AWarehouse > initwh_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAConnectUImpl();
};
// -------------------------------------------------------------------

class AGoodInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AGoodInfo) */ {
 public:
  AGoodInfo();
  virtual ~AGoodInfo();

  AGoodInfo(const AGoodInfo& from);

  inline AGoodInfo& operator=(const AGoodInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AGoodInfo(AGoodInfo&& from) noexcept
    : AGoodInfo() {
    *this = ::std::move(from);
  }

  inline AGoodInfo& operator=(AGoodInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AGoodInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AGoodInfo* internal_default_instance() {
    return reinterpret_cast<const AGoodInfo*>(
               &_AGoodInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(AGoodInfo* other);
  friend void swap(AGoodInfo& a, AGoodInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AGoodInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  AGoodInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AGoodInfo& from);
  void MergeFrom(const AGoodInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AGoodInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AProduct good = 6;
  int good_size() const;
  void clear_good();
  static const int kGoodFieldNumber = 6;
  const ::AProduct& good(int index) const;
  ::AProduct* mutable_good(int index);
  ::AProduct* add_good();
  ::google::protobuf::RepeatedPtrField< ::AProduct >*
      mutable_good();
  const ::google::protobuf::RepeatedPtrField< ::AProduct >&
      good() const;

  // optional string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required int32 whid = 1;
  bool has_whid() const;
  void clear_whid();
  static const int kWhidFieldNumber = 1;
  ::google::protobuf::int32 whid() const;
  void set_whid(::google::protobuf::int32 value);

  // required int32 xdest = 3;
  bool has_xdest() const;
  void clear_xdest();
  static const int kXdestFieldNumber = 3;
  ::google::protobuf::int32 xdest() const;
  void set_xdest(::google::protobuf::int32 value);

  // required int64 order_num = 5;
  bool has_order_num() const;
  void clear_order_num();
  static const int kOrderNumFieldNumber = 5;
  ::google::protobuf::int64 order_num() const;
  void set_order_num(::google::protobuf::int64 value);

  // required int32 ydest = 4;
  bool has_ydest() const;
  void clear_ydest();
  static const int kYdestFieldNumber = 4;
  ::google::protobuf::int32 ydest() const;
  void set_ydest(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AGoodInfo)
 private:
  void set_has_whid();
  void clear_has_whid();
  void set_has_username();
  void clear_has_username();
  void set_has_xdest();
  void clear_has_xdest();
  void set_has_ydest();
  void clear_has_ydest();
  void set_has_order_num();
  void clear_has_order_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AProduct > good_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 whid_;
  ::google::protobuf::int32 xdest_;
  ::google::protobuf::int64 order_num_;
  ::google::protobuf::int32 ydest_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsAGoodInfoImpl();
};
// -------------------------------------------------------------------

class UTruckMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UTruckMatch) */ {
 public:
  UTruckMatch();
  virtual ~UTruckMatch();

  UTruckMatch(const UTruckMatch& from);

  inline UTruckMatch& operator=(const UTruckMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UTruckMatch(UTruckMatch&& from) noexcept
    : UTruckMatch() {
    *this = ::std::move(from);
  }

  inline UTruckMatch& operator=(UTruckMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UTruckMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UTruckMatch* internal_default_instance() {
    return reinterpret_cast<const UTruckMatch*>(
               &_UTruckMatch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(UTruckMatch* other);
  friend void swap(UTruckMatch& a, UTruckMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UTruckMatch* New() const PROTOBUF_FINAL { return New(NULL); }

  UTruckMatch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UTruckMatch& from);
  void MergeFrom(const UTruckMatch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UTruckMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 goodid = 2;
  bool has_goodid() const;
  void clear_goodid();
  static const int kGoodidFieldNumber = 2;
  ::google::protobuf::int64 goodid() const;
  void set_goodid(::google::protobuf::int64 value);

  // required int64 order_num = 3;
  bool has_order_num() const;
  void clear_order_num();
  static const int kOrderNumFieldNumber = 3;
  ::google::protobuf::int64 order_num() const;
  void set_order_num(::google::protobuf::int64 value);

  // required int32 truckid = 1;
  bool has_truckid() const;
  void clear_truckid();
  static const int kTruckidFieldNumber = 1;
  ::google::protobuf::int32 truckid() const;
  void set_truckid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UTruckMatch)
 private:
  void set_has_truckid();
  void clear_has_truckid();
  void set_has_goodid();
  void clear_has_goodid();
  void set_has_order_num();
  void clear_has_order_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 goodid_;
  ::google::protobuf::int64 order_num_;
  ::google::protobuf::int32 truckid_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsUTruckMatchImpl();
};
// -------------------------------------------------------------------

class UTruckInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UTruckInfo) */ {
 public:
  UTruckInfo();
  virtual ~UTruckInfo();

  UTruckInfo(const UTruckInfo& from);

  inline UTruckInfo& operator=(const UTruckInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UTruckInfo(UTruckInfo&& from) noexcept
    : UTruckInfo() {
    *this = ::std::move(from);
  }

  inline UTruckInfo& operator=(UTruckInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UTruckInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UTruckInfo* internal_default_instance() {
    return reinterpret_cast<const UTruckInfo*>(
               &_UTruckInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(UTruckInfo* other);
  friend void swap(UTruckInfo& a, UTruckInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UTruckInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  UTruckInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UTruckInfo& from);
  void MergeFrom(const UTruckInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UTruckInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 truckid = 1;
  bool has_truckid() const;
  void clear_truckid();
  static const int kTruckidFieldNumber = 1;
  ::google::protobuf::int32 truckid() const;
  void set_truckid(::google::protobuf::int32 value);

  // required int32 whid = 2;
  bool has_whid() const;
  void clear_whid();
  static const int kWhidFieldNumber = 2;
  ::google::protobuf::int32 whid() const;
  void set_whid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UTruckInfo)
 private:
  void set_has_truckid();
  void clear_has_truckid();
  void set_has_whid();
  void clear_has_whid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 truckid_;
  ::google::protobuf::int32 whid_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsUTruckInfoImpl();
};
// -------------------------------------------------------------------

class A2UResponses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:A2UResponses) */ {
 public:
  A2UResponses();
  virtual ~A2UResponses();

  A2UResponses(const A2UResponses& from);

  inline A2UResponses& operator=(const A2UResponses& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  A2UResponses(A2UResponses&& from) noexcept
    : A2UResponses() {
    *this = ::std::move(from);
  }

  inline A2UResponses& operator=(A2UResponses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const A2UResponses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const A2UResponses* internal_default_instance() {
    return reinterpret_cast<const A2UResponses*>(
               &_A2UResponses_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(A2UResponses* other);
  friend void swap(A2UResponses& a, A2UResponses& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline A2UResponses* New() const PROTOBUF_FINAL { return New(NULL); }

  A2UResponses* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const A2UResponses& from);
  void MergeFrom(const A2UResponses& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(A2UResponses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AGoodInfo goodReady = 1;
  int goodready_size() const;
  void clear_goodready();
  static const int kGoodReadyFieldNumber = 1;
  const ::AGoodInfo& goodready(int index) const;
  ::AGoodInfo* mutable_goodready(int index);
  ::AGoodInfo* add_goodready();
  ::google::protobuf::RepeatedPtrField< ::AGoodInfo >*
      mutable_goodready();
  const ::google::protobuf::RepeatedPtrField< ::AGoodInfo >&
      goodready() const;

  // repeated .UTruckInfo truckLeave = 2;
  int truckleave_size() const;
  void clear_truckleave();
  static const int kTruckLeaveFieldNumber = 2;
  const ::UTruckInfo& truckleave(int index) const;
  ::UTruckInfo* mutable_truckleave(int index);
  ::UTruckInfo* add_truckleave();
  ::google::protobuf::RepeatedPtrField< ::UTruckInfo >*
      mutable_truckleave();
  const ::google::protobuf::RepeatedPtrField< ::UTruckInfo >&
      truckleave() const;

  // optional string error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:A2UResponses)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AGoodInfo > goodready_;
  ::google::protobuf::RepeatedPtrField< ::UTruckInfo > truckleave_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsA2UResponsesImpl();
};
// -------------------------------------------------------------------

class U2AResponses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:U2AResponses) */ {
 public:
  U2AResponses();
  virtual ~U2AResponses();

  U2AResponses(const U2AResponses& from);

  inline U2AResponses& operator=(const U2AResponses& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  U2AResponses(U2AResponses&& from) noexcept
    : U2AResponses() {
    *this = ::std::move(from);
  }

  inline U2AResponses& operator=(U2AResponses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const U2AResponses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const U2AResponses* internal_default_instance() {
    return reinterpret_cast<const U2AResponses*>(
               &_U2AResponses_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(U2AResponses* other);
  friend void swap(U2AResponses& a, U2AResponses& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline U2AResponses* New() const PROTOBUF_FINAL { return New(NULL); }

  U2AResponses* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const U2AResponses& from);
  void MergeFrom(const U2AResponses& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(U2AResponses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UTruckInfo truckArrived = 1;
  int truckarrived_size() const;
  void clear_truckarrived();
  static const int kTruckArrivedFieldNumber = 1;
  const ::UTruckInfo& truckarrived(int index) const;
  ::UTruckInfo* mutable_truckarrived(int index);
  ::UTruckInfo* add_truckarrived();
  ::google::protobuf::RepeatedPtrField< ::UTruckInfo >*
      mutable_truckarrived();
  const ::google::protobuf::RepeatedPtrField< ::UTruckInfo >&
      truckarrived() const;

  // repeated int64 packageFinished = 2;
  int packagefinished_size() const;
  void clear_packagefinished();
  static const int kPackageFinishedFieldNumber = 2;
  ::google::protobuf::int64 packagefinished(int index) const;
  void set_packagefinished(int index, ::google::protobuf::int64 value);
  void add_packagefinished(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      packagefinished() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_packagefinished();

  // repeated .UTruckMatch truckReady = 3;
  int truckready_size() const;
  void clear_truckready();
  static const int kTruckReadyFieldNumber = 3;
  const ::UTruckMatch& truckready(int index) const;
  ::UTruckMatch* mutable_truckready(int index);
  ::UTruckMatch* add_truckready();
  ::google::protobuf::RepeatedPtrField< ::UTruckMatch >*
      mutable_truckready();
  const ::google::protobuf::RepeatedPtrField< ::UTruckMatch >&
      truckready() const;

  // optional string error = 4;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 4;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:U2AResponses)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::UTruckInfo > truckarrived_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > packagefinished_;
  ::google::protobuf::RepeatedPtrField< ::UTruckMatch > truckready_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  friend struct ::protobuf_amazon_2eproto::TableStruct;
  friend void ::protobuf_amazon_2eproto::InitDefaultsU2AResponsesImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AProduct

// required int64 id = 1;
inline bool AProduct::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AProduct::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AProduct::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AProduct::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 AProduct::id() const {
  // @@protoc_insertion_point(field_get:AProduct.id)
  return id_;
}
inline void AProduct::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AProduct.id)
}

// required string description = 2;
inline bool AProduct::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AProduct::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AProduct::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AProduct::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& AProduct::description() const {
  // @@protoc_insertion_point(field_get:AProduct.description)
  return description_.GetNoArena();
}
inline void AProduct::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AProduct.description)
}
#if LANG_CXX11
inline void AProduct::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AProduct.description)
}
#endif
inline void AProduct::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AProduct.description)
}
inline void AProduct::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AProduct.description)
}
inline ::std::string* AProduct::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:AProduct.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AProduct::release_description() {
  // @@protoc_insertion_point(field_release:AProduct.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AProduct::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:AProduct.description)
}

// required int32 count = 3;
inline bool AProduct::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AProduct::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AProduct::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AProduct::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 AProduct::count() const {
  // @@protoc_insertion_point(field_get:AProduct.count)
  return count_;
}
inline void AProduct::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:AProduct.count)
}

// -------------------------------------------------------------------

// AInitWarehouse

// required int32 x = 1;
inline bool AInitWarehouse::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AInitWarehouse::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AInitWarehouse::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AInitWarehouse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 AInitWarehouse::x() const {
  // @@protoc_insertion_point(field_get:AInitWarehouse.x)
  return x_;
}
inline void AInitWarehouse::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:AInitWarehouse.x)
}

// required int32 y = 2;
inline bool AInitWarehouse::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AInitWarehouse::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AInitWarehouse::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AInitWarehouse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 AInitWarehouse::y() const {
  // @@protoc_insertion_point(field_get:AInitWarehouse.y)
  return y_;
}
inline void AInitWarehouse::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:AInitWarehouse.y)
}

// -------------------------------------------------------------------

// AConnect

// required int64 worldid = 1;
inline bool AConnect::has_worldid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AConnect::set_has_worldid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AConnect::clear_has_worldid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AConnect::clear_worldid() {
  worldid_ = GOOGLE_LONGLONG(0);
  clear_has_worldid();
}
inline ::google::protobuf::int64 AConnect::worldid() const {
  // @@protoc_insertion_point(field_get:AConnect.worldid)
  return worldid_;
}
inline void AConnect::set_worldid(::google::protobuf::int64 value) {
  set_has_worldid();
  worldid_ = value;
  // @@protoc_insertion_point(field_set:AConnect.worldid)
}

// repeated .AInitWarehouse initwh = 2;
inline int AConnect::initwh_size() const {
  return initwh_.size();
}
inline void AConnect::clear_initwh() {
  initwh_.Clear();
}
inline const ::AInitWarehouse& AConnect::initwh(int index) const {
  // @@protoc_insertion_point(field_get:AConnect.initwh)
  return initwh_.Get(index);
}
inline ::AInitWarehouse* AConnect::mutable_initwh(int index) {
  // @@protoc_insertion_point(field_mutable:AConnect.initwh)
  return initwh_.Mutable(index);
}
inline ::AInitWarehouse* AConnect::add_initwh() {
  // @@protoc_insertion_point(field_add:AConnect.initwh)
  return initwh_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::AInitWarehouse >*
AConnect::mutable_initwh() {
  // @@protoc_insertion_point(field_mutable_list:AConnect.initwh)
  return &initwh_;
}
inline const ::google::protobuf::RepeatedPtrField< ::AInitWarehouse >&
AConnect::initwh() const {
  // @@protoc_insertion_point(field_list:AConnect.initwh)
  return initwh_;
}

// -------------------------------------------------------------------

// AConnected

// optional string error = 1;
inline bool AConnected::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AConnected::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AConnected::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AConnected::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& AConnected::error() const {
  // @@protoc_insertion_point(field_get:AConnected.error)
  return error_.GetNoArena();
}
inline void AConnected::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AConnected.error)
}
#if LANG_CXX11
inline void AConnected::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AConnected.error)
}
#endif
inline void AConnected::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AConnected.error)
}
inline void AConnected::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AConnected.error)
}
inline ::std::string* AConnected::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:AConnected.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AConnected::release_error() {
  // @@protoc_insertion_point(field_release:AConnected.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AConnected::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:AConnected.error)
}

// -------------------------------------------------------------------

// APack

// required int32 whnum = 1;
inline bool APack::has_whnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void APack::set_has_whnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void APack::clear_has_whnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void APack::clear_whnum() {
  whnum_ = 0;
  clear_has_whnum();
}
inline ::google::protobuf::int32 APack::whnum() const {
  // @@protoc_insertion_point(field_get:APack.whnum)
  return whnum_;
}
inline void APack::set_whnum(::google::protobuf::int32 value) {
  set_has_whnum();
  whnum_ = value;
  // @@protoc_insertion_point(field_set:APack.whnum)
}

// repeated .AProduct things = 2;
inline int APack::things_size() const {
  return things_.size();
}
inline void APack::clear_things() {
  things_.Clear();
}
inline const ::AProduct& APack::things(int index) const {
  // @@protoc_insertion_point(field_get:APack.things)
  return things_.Get(index);
}
inline ::AProduct* APack::mutable_things(int index) {
  // @@protoc_insertion_point(field_mutable:APack.things)
  return things_.Mutable(index);
}
inline ::AProduct* APack::add_things() {
  // @@protoc_insertion_point(field_add:APack.things)
  return things_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::AProduct >*
APack::mutable_things() {
  // @@protoc_insertion_point(field_mutable_list:APack.things)
  return &things_;
}
inline const ::google::protobuf::RepeatedPtrField< ::AProduct >&
APack::things() const {
  // @@protoc_insertion_point(field_list:APack.things)
  return things_;
}

// required int64 shipid = 3;
inline bool APack::has_shipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void APack::set_has_shipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void APack::clear_has_shipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void APack::clear_shipid() {
  shipid_ = GOOGLE_LONGLONG(0);
  clear_has_shipid();
}
inline ::google::protobuf::int64 APack::shipid() const {
  // @@protoc_insertion_point(field_get:APack.shipid)
  return shipid_;
}
inline void APack::set_shipid(::google::protobuf::int64 value) {
  set_has_shipid();
  shipid_ = value;
  // @@protoc_insertion_point(field_set:APack.shipid)
}

// -------------------------------------------------------------------

// APutOnTruck

// required int32 whnum = 1;
inline bool APutOnTruck::has_whnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void APutOnTruck::set_has_whnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void APutOnTruck::clear_has_whnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void APutOnTruck::clear_whnum() {
  whnum_ = 0;
  clear_has_whnum();
}
inline ::google::protobuf::int32 APutOnTruck::whnum() const {
  // @@protoc_insertion_point(field_get:APutOnTruck.whnum)
  return whnum_;
}
inline void APutOnTruck::set_whnum(::google::protobuf::int32 value) {
  set_has_whnum();
  whnum_ = value;
  // @@protoc_insertion_point(field_set:APutOnTruck.whnum)
}

// required int32 truckid = 2;
inline bool APutOnTruck::has_truckid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void APutOnTruck::set_has_truckid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void APutOnTruck::clear_has_truckid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void APutOnTruck::clear_truckid() {
  truckid_ = 0;
  clear_has_truckid();
}
inline ::google::protobuf::int32 APutOnTruck::truckid() const {
  // @@protoc_insertion_point(field_get:APutOnTruck.truckid)
  return truckid_;
}
inline void APutOnTruck::set_truckid(::google::protobuf::int32 value) {
  set_has_truckid();
  truckid_ = value;
  // @@protoc_insertion_point(field_set:APutOnTruck.truckid)
}

// required int64 shipid = 3;
inline bool APutOnTruck::has_shipid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void APutOnTruck::set_has_shipid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void APutOnTruck::clear_has_shipid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void APutOnTruck::clear_shipid() {
  shipid_ = GOOGLE_LONGLONG(0);
  clear_has_shipid();
}
inline ::google::protobuf::int64 APutOnTruck::shipid() const {
  // @@protoc_insertion_point(field_get:APutOnTruck.shipid)
  return shipid_;
}
inline void APutOnTruck::set_shipid(::google::protobuf::int64 value) {
  set_has_shipid();
  shipid_ = value;
  // @@protoc_insertion_point(field_set:APutOnTruck.shipid)
}

// -------------------------------------------------------------------

// APurchaseMore

// required int32 whnum = 1;
inline bool APurchaseMore::has_whnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void APurchaseMore::set_has_whnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void APurchaseMore::clear_has_whnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void APurchaseMore::clear_whnum() {
  whnum_ = 0;
  clear_has_whnum();
}
inline ::google::protobuf::int32 APurchaseMore::whnum() const {
  // @@protoc_insertion_point(field_get:APurchaseMore.whnum)
  return whnum_;
}
inline void APurchaseMore::set_whnum(::google::protobuf::int32 value) {
  set_has_whnum();
  whnum_ = value;
  // @@protoc_insertion_point(field_set:APurchaseMore.whnum)
}

// repeated .AProduct things = 2;
inline int APurchaseMore::things_size() const {
  return things_.size();
}
inline void APurchaseMore::clear_things() {
  things_.Clear();
}
inline const ::AProduct& APurchaseMore::things(int index) const {
  // @@protoc_insertion_point(field_get:APurchaseMore.things)
  return things_.Get(index);
}
inline ::AProduct* APurchaseMore::mutable_things(int index) {
  // @@protoc_insertion_point(field_mutable:APurchaseMore.things)
  return things_.Mutable(index);
}
inline ::AProduct* APurchaseMore::add_things() {
  // @@protoc_insertion_point(field_add:APurchaseMore.things)
  return things_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::AProduct >*
APurchaseMore::mutable_things() {
  // @@protoc_insertion_point(field_mutable_list:APurchaseMore.things)
  return &things_;
}
inline const ::google::protobuf::RepeatedPtrField< ::AProduct >&
APurchaseMore::things() const {
  // @@protoc_insertion_point(field_list:APurchaseMore.things)
  return things_;
}

// -------------------------------------------------------------------

// ACommands

// repeated .APurchaseMore buy = 1;
inline int ACommands::buy_size() const {
  return buy_.size();
}
inline void ACommands::clear_buy() {
  buy_.Clear();
}
inline const ::APurchaseMore& ACommands::buy(int index) const {
  // @@protoc_insertion_point(field_get:ACommands.buy)
  return buy_.Get(index);
}
inline ::APurchaseMore* ACommands::mutable_buy(int index) {
  // @@protoc_insertion_point(field_mutable:ACommands.buy)
  return buy_.Mutable(index);
}
inline ::APurchaseMore* ACommands::add_buy() {
  // @@protoc_insertion_point(field_add:ACommands.buy)
  return buy_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::APurchaseMore >*
ACommands::mutable_buy() {
  // @@protoc_insertion_point(field_mutable_list:ACommands.buy)
  return &buy_;
}
inline const ::google::protobuf::RepeatedPtrField< ::APurchaseMore >&
ACommands::buy() const {
  // @@protoc_insertion_point(field_list:ACommands.buy)
  return buy_;
}

// repeated .APutOnTruck load = 2;
inline int ACommands::load_size() const {
  return load_.size();
}
inline void ACommands::clear_load() {
  load_.Clear();
}
inline const ::APutOnTruck& ACommands::load(int index) const {
  // @@protoc_insertion_point(field_get:ACommands.load)
  return load_.Get(index);
}
inline ::APutOnTruck* ACommands::mutable_load(int index) {
  // @@protoc_insertion_point(field_mutable:ACommands.load)
  return load_.Mutable(index);
}
inline ::APutOnTruck* ACommands::add_load() {
  // @@protoc_insertion_point(field_add:ACommands.load)
  return load_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::APutOnTruck >*
ACommands::mutable_load() {
  // @@protoc_insertion_point(field_mutable_list:ACommands.load)
  return &load_;
}
inline const ::google::protobuf::RepeatedPtrField< ::APutOnTruck >&
ACommands::load() const {
  // @@protoc_insertion_point(field_list:ACommands.load)
  return load_;
}

// repeated .APack topack = 3;
inline int ACommands::topack_size() const {
  return topack_.size();
}
inline void ACommands::clear_topack() {
  topack_.Clear();
}
inline const ::APack& ACommands::topack(int index) const {
  // @@protoc_insertion_point(field_get:ACommands.topack)
  return topack_.Get(index);
}
inline ::APack* ACommands::mutable_topack(int index) {
  // @@protoc_insertion_point(field_mutable:ACommands.topack)
  return topack_.Mutable(index);
}
inline ::APack* ACommands::add_topack() {
  // @@protoc_insertion_point(field_add:ACommands.topack)
  return topack_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::APack >*
ACommands::mutable_topack() {
  // @@protoc_insertion_point(field_mutable_list:ACommands.topack)
  return &topack_;
}
inline const ::google::protobuf::RepeatedPtrField< ::APack >&
ACommands::topack() const {
  // @@protoc_insertion_point(field_list:ACommands.topack)
  return topack_;
}

// optional uint32 simspeed = 4;
inline bool ACommands::has_simspeed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACommands::set_has_simspeed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACommands::clear_has_simspeed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACommands::clear_simspeed() {
  simspeed_ = 0u;
  clear_has_simspeed();
}
inline ::google::protobuf::uint32 ACommands::simspeed() const {
  // @@protoc_insertion_point(field_get:ACommands.simspeed)
  return simspeed_;
}
inline void ACommands::set_simspeed(::google::protobuf::uint32 value) {
  set_has_simspeed();
  simspeed_ = value;
  // @@protoc_insertion_point(field_set:ACommands.simspeed)
}

// optional bool disconnect = 5;
inline bool ACommands::has_disconnect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACommands::set_has_disconnect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACommands::clear_has_disconnect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACommands::clear_disconnect() {
  disconnect_ = false;
  clear_has_disconnect();
}
inline bool ACommands::disconnect() const {
  // @@protoc_insertion_point(field_get:ACommands.disconnect)
  return disconnect_;
}
inline void ACommands::set_disconnect(bool value) {
  set_has_disconnect();
  disconnect_ = value;
  // @@protoc_insertion_point(field_set:ACommands.disconnect)
}

// -------------------------------------------------------------------

// AResponses

// repeated .APurchaseMore arrived = 1;
inline int AResponses::arrived_size() const {
  return arrived_.size();
}
inline void AResponses::clear_arrived() {
  arrived_.Clear();
}
inline const ::APurchaseMore& AResponses::arrived(int index) const {
  // @@protoc_insertion_point(field_get:AResponses.arrived)
  return arrived_.Get(index);
}
inline ::APurchaseMore* AResponses::mutable_arrived(int index) {
  // @@protoc_insertion_point(field_mutable:AResponses.arrived)
  return arrived_.Mutable(index);
}
inline ::APurchaseMore* AResponses::add_arrived() {
  // @@protoc_insertion_point(field_add:AResponses.arrived)
  return arrived_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::APurchaseMore >*
AResponses::mutable_arrived() {
  // @@protoc_insertion_point(field_mutable_list:AResponses.arrived)
  return &arrived_;
}
inline const ::google::protobuf::RepeatedPtrField< ::APurchaseMore >&
AResponses::arrived() const {
  // @@protoc_insertion_point(field_list:AResponses.arrived)
  return arrived_;
}

// repeated int64 ready = 2;
inline int AResponses::ready_size() const {
  return ready_.size();
}
inline void AResponses::clear_ready() {
  ready_.Clear();
}
inline ::google::protobuf::int64 AResponses::ready(int index) const {
  // @@protoc_insertion_point(field_get:AResponses.ready)
  return ready_.Get(index);
}
inline void AResponses::set_ready(int index, ::google::protobuf::int64 value) {
  ready_.Set(index, value);
  // @@protoc_insertion_point(field_set:AResponses.ready)
}
inline void AResponses::add_ready(::google::protobuf::int64 value) {
  ready_.Add(value);
  // @@protoc_insertion_point(field_add:AResponses.ready)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AResponses::ready() const {
  // @@protoc_insertion_point(field_list:AResponses.ready)
  return ready_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AResponses::mutable_ready() {
  // @@protoc_insertion_point(field_mutable_list:AResponses.ready)
  return &ready_;
}

// repeated int64 loaded = 3;
inline int AResponses::loaded_size() const {
  return loaded_.size();
}
inline void AResponses::clear_loaded() {
  loaded_.Clear();
}
inline ::google::protobuf::int64 AResponses::loaded(int index) const {
  // @@protoc_insertion_point(field_get:AResponses.loaded)
  return loaded_.Get(index);
}
inline void AResponses::set_loaded(int index, ::google::protobuf::int64 value) {
  loaded_.Set(index, value);
  // @@protoc_insertion_point(field_set:AResponses.loaded)
}
inline void AResponses::add_loaded(::google::protobuf::int64 value) {
  loaded_.Add(value);
  // @@protoc_insertion_point(field_add:AResponses.loaded)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AResponses::loaded() const {
  // @@protoc_insertion_point(field_list:AResponses.loaded)
  return loaded_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AResponses::mutable_loaded() {
  // @@protoc_insertion_point(field_mutable_list:AResponses.loaded)
  return &loaded_;
}

// optional string error = 4;
inline bool AResponses::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AResponses::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AResponses::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AResponses::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& AResponses::error() const {
  // @@protoc_insertion_point(field_get:AResponses.error)
  return error_.GetNoArena();
}
inline void AResponses::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AResponses.error)
}
#if LANG_CXX11
inline void AResponses::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AResponses.error)
}
#endif
inline void AResponses::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AResponses.error)
}
inline void AResponses::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AResponses.error)
}
inline ::std::string* AResponses::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:AResponses.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AResponses::release_error() {
  // @@protoc_insertion_point(field_release:AResponses.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AResponses::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:AResponses.error)
}

// optional bool finished = 5;
inline bool AResponses::has_finished() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AResponses::set_has_finished() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AResponses::clear_has_finished() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AResponses::clear_finished() {
  finished_ = false;
  clear_has_finished();
}
inline bool AResponses::finished() const {
  // @@protoc_insertion_point(field_get:AResponses.finished)
  return finished_;
}
inline void AResponses::set_finished(bool value) {
  set_has_finished();
  finished_ = value;
  // @@protoc_insertion_point(field_set:AResponses.finished)
}

// -------------------------------------------------------------------

// AWarehouse

// required int32 wid = 1;
inline bool AWarehouse::has_wid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AWarehouse::set_has_wid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AWarehouse::clear_has_wid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AWarehouse::clear_wid() {
  wid_ = 0;
  clear_has_wid();
}
inline ::google::protobuf::int32 AWarehouse::wid() const {
  // @@protoc_insertion_point(field_get:AWarehouse.wid)
  return wid_;
}
inline void AWarehouse::set_wid(::google::protobuf::int32 value) {
  set_has_wid();
  wid_ = value;
  // @@protoc_insertion_point(field_set:AWarehouse.wid)
}

// required int32 x = 2;
inline bool AWarehouse::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AWarehouse::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AWarehouse::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AWarehouse::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 AWarehouse::x() const {
  // @@protoc_insertion_point(field_get:AWarehouse.x)
  return x_;
}
inline void AWarehouse::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:AWarehouse.x)
}

// required int32 y = 3;
inline bool AWarehouse::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AWarehouse::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AWarehouse::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AWarehouse::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 AWarehouse::y() const {
  // @@protoc_insertion_point(field_get:AWarehouse.y)
  return y_;
}
inline void AWarehouse::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:AWarehouse.y)
}

// -------------------------------------------------------------------

// UConnectA

// required int64 worldid = 1;
inline bool UConnectA::has_worldid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UConnectA::set_has_worldid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UConnectA::clear_has_worldid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UConnectA::clear_worldid() {
  worldid_ = GOOGLE_LONGLONG(0);
  clear_has_worldid();
}
inline ::google::protobuf::int64 UConnectA::worldid() const {
  // @@protoc_insertion_point(field_get:UConnectA.worldid)
  return worldid_;
}
inline void UConnectA::set_worldid(::google::protobuf::int64 value) {
  set_has_worldid();
  worldid_ = value;
  // @@protoc_insertion_point(field_set:UConnectA.worldid)
}

// -------------------------------------------------------------------

// AConnectU

// repeated .AWarehouse initwh = 1;
inline int AConnectU::initwh_size() const {
  return initwh_.size();
}
inline void AConnectU::clear_initwh() {
  initwh_.Clear();
}
inline const ::AWarehouse& AConnectU::initwh(int index) const {
  // @@protoc_insertion_point(field_get:AConnectU.initwh)
  return initwh_.Get(index);
}
inline ::AWarehouse* AConnectU::mutable_initwh(int index) {
  // @@protoc_insertion_point(field_mutable:AConnectU.initwh)
  return initwh_.Mutable(index);
}
inline ::AWarehouse* AConnectU::add_initwh() {
  // @@protoc_insertion_point(field_add:AConnectU.initwh)
  return initwh_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::AWarehouse >*
AConnectU::mutable_initwh() {
  // @@protoc_insertion_point(field_mutable_list:AConnectU.initwh)
  return &initwh_;
}
inline const ::google::protobuf::RepeatedPtrField< ::AWarehouse >&
AConnectU::initwh() const {
  // @@protoc_insertion_point(field_list:AConnectU.initwh)
  return initwh_;
}

// optional string error = 2;
inline bool AConnectU::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AConnectU::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AConnectU::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AConnectU::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& AConnectU::error() const {
  // @@protoc_insertion_point(field_get:AConnectU.error)
  return error_.GetNoArena();
}
inline void AConnectU::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AConnectU.error)
}
#if LANG_CXX11
inline void AConnectU::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AConnectU.error)
}
#endif
inline void AConnectU::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AConnectU.error)
}
inline void AConnectU::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AConnectU.error)
}
inline ::std::string* AConnectU::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:AConnectU.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AConnectU::release_error() {
  // @@protoc_insertion_point(field_release:AConnectU.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AConnectU::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:AConnectU.error)
}

// -------------------------------------------------------------------

// AGoodInfo

// required int32 whid = 1;
inline bool AGoodInfo::has_whid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AGoodInfo::set_has_whid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AGoodInfo::clear_has_whid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AGoodInfo::clear_whid() {
  whid_ = 0;
  clear_has_whid();
}
inline ::google::protobuf::int32 AGoodInfo::whid() const {
  // @@protoc_insertion_point(field_get:AGoodInfo.whid)
  return whid_;
}
inline void AGoodInfo::set_whid(::google::protobuf::int32 value) {
  set_has_whid();
  whid_ = value;
  // @@protoc_insertion_point(field_set:AGoodInfo.whid)
}

// optional string username = 2;
inline bool AGoodInfo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AGoodInfo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AGoodInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AGoodInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& AGoodInfo::username() const {
  // @@protoc_insertion_point(field_get:AGoodInfo.username)
  return username_.GetNoArena();
}
inline void AGoodInfo::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AGoodInfo.username)
}
#if LANG_CXX11
inline void AGoodInfo::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AGoodInfo.username)
}
#endif
inline void AGoodInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AGoodInfo.username)
}
inline void AGoodInfo::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AGoodInfo.username)
}
inline ::std::string* AGoodInfo::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:AGoodInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AGoodInfo::release_username() {
  // @@protoc_insertion_point(field_release:AGoodInfo.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AGoodInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:AGoodInfo.username)
}

// required int32 xdest = 3;
inline bool AGoodInfo::has_xdest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AGoodInfo::set_has_xdest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AGoodInfo::clear_has_xdest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AGoodInfo::clear_xdest() {
  xdest_ = 0;
  clear_has_xdest();
}
inline ::google::protobuf::int32 AGoodInfo::xdest() const {
  // @@protoc_insertion_point(field_get:AGoodInfo.xdest)
  return xdest_;
}
inline void AGoodInfo::set_xdest(::google::protobuf::int32 value) {
  set_has_xdest();
  xdest_ = value;
  // @@protoc_insertion_point(field_set:AGoodInfo.xdest)
}

// required int32 ydest = 4;
inline bool AGoodInfo::has_ydest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AGoodInfo::set_has_ydest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AGoodInfo::clear_has_ydest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AGoodInfo::clear_ydest() {
  ydest_ = 0;
  clear_has_ydest();
}
inline ::google::protobuf::int32 AGoodInfo::ydest() const {
  // @@protoc_insertion_point(field_get:AGoodInfo.ydest)
  return ydest_;
}
inline void AGoodInfo::set_ydest(::google::protobuf::int32 value) {
  set_has_ydest();
  ydest_ = value;
  // @@protoc_insertion_point(field_set:AGoodInfo.ydest)
}

// required int64 order_num = 5;
inline bool AGoodInfo::has_order_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AGoodInfo::set_has_order_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AGoodInfo::clear_has_order_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AGoodInfo::clear_order_num() {
  order_num_ = GOOGLE_LONGLONG(0);
  clear_has_order_num();
}
inline ::google::protobuf::int64 AGoodInfo::order_num() const {
  // @@protoc_insertion_point(field_get:AGoodInfo.order_num)
  return order_num_;
}
inline void AGoodInfo::set_order_num(::google::protobuf::int64 value) {
  set_has_order_num();
  order_num_ = value;
  // @@protoc_insertion_point(field_set:AGoodInfo.order_num)
}

// repeated .AProduct good = 6;
inline int AGoodInfo::good_size() const {
  return good_.size();
}
inline void AGoodInfo::clear_good() {
  good_.Clear();
}
inline const ::AProduct& AGoodInfo::good(int index) const {
  // @@protoc_insertion_point(field_get:AGoodInfo.good)
  return good_.Get(index);
}
inline ::AProduct* AGoodInfo::mutable_good(int index) {
  // @@protoc_insertion_point(field_mutable:AGoodInfo.good)
  return good_.Mutable(index);
}
inline ::AProduct* AGoodInfo::add_good() {
  // @@protoc_insertion_point(field_add:AGoodInfo.good)
  return good_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::AProduct >*
AGoodInfo::mutable_good() {
  // @@protoc_insertion_point(field_mutable_list:AGoodInfo.good)
  return &good_;
}
inline const ::google::protobuf::RepeatedPtrField< ::AProduct >&
AGoodInfo::good() const {
  // @@protoc_insertion_point(field_list:AGoodInfo.good)
  return good_;
}

// -------------------------------------------------------------------

// UTruckMatch

// required int32 truckid = 1;
inline bool UTruckMatch::has_truckid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UTruckMatch::set_has_truckid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UTruckMatch::clear_has_truckid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UTruckMatch::clear_truckid() {
  truckid_ = 0;
  clear_has_truckid();
}
inline ::google::protobuf::int32 UTruckMatch::truckid() const {
  // @@protoc_insertion_point(field_get:UTruckMatch.truckid)
  return truckid_;
}
inline void UTruckMatch::set_truckid(::google::protobuf::int32 value) {
  set_has_truckid();
  truckid_ = value;
  // @@protoc_insertion_point(field_set:UTruckMatch.truckid)
}

// required int64 goodid = 2;
inline bool UTruckMatch::has_goodid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UTruckMatch::set_has_goodid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UTruckMatch::clear_has_goodid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UTruckMatch::clear_goodid() {
  goodid_ = GOOGLE_LONGLONG(0);
  clear_has_goodid();
}
inline ::google::protobuf::int64 UTruckMatch::goodid() const {
  // @@protoc_insertion_point(field_get:UTruckMatch.goodid)
  return goodid_;
}
inline void UTruckMatch::set_goodid(::google::protobuf::int64 value) {
  set_has_goodid();
  goodid_ = value;
  // @@protoc_insertion_point(field_set:UTruckMatch.goodid)
}

// required int64 order_num = 3;
inline bool UTruckMatch::has_order_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UTruckMatch::set_has_order_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UTruckMatch::clear_has_order_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UTruckMatch::clear_order_num() {
  order_num_ = GOOGLE_LONGLONG(0);
  clear_has_order_num();
}
inline ::google::protobuf::int64 UTruckMatch::order_num() const {
  // @@protoc_insertion_point(field_get:UTruckMatch.order_num)
  return order_num_;
}
inline void UTruckMatch::set_order_num(::google::protobuf::int64 value) {
  set_has_order_num();
  order_num_ = value;
  // @@protoc_insertion_point(field_set:UTruckMatch.order_num)
}

// -------------------------------------------------------------------

// UTruckInfo

// required int32 truckid = 1;
inline bool UTruckInfo::has_truckid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UTruckInfo::set_has_truckid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UTruckInfo::clear_has_truckid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UTruckInfo::clear_truckid() {
  truckid_ = 0;
  clear_has_truckid();
}
inline ::google::protobuf::int32 UTruckInfo::truckid() const {
  // @@protoc_insertion_point(field_get:UTruckInfo.truckid)
  return truckid_;
}
inline void UTruckInfo::set_truckid(::google::protobuf::int32 value) {
  set_has_truckid();
  truckid_ = value;
  // @@protoc_insertion_point(field_set:UTruckInfo.truckid)
}

// required int32 whid = 2;
inline bool UTruckInfo::has_whid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UTruckInfo::set_has_whid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UTruckInfo::clear_has_whid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UTruckInfo::clear_whid() {
  whid_ = 0;
  clear_has_whid();
}
inline ::google::protobuf::int32 UTruckInfo::whid() const {
  // @@protoc_insertion_point(field_get:UTruckInfo.whid)
  return whid_;
}
inline void UTruckInfo::set_whid(::google::protobuf::int32 value) {
  set_has_whid();
  whid_ = value;
  // @@protoc_insertion_point(field_set:UTruckInfo.whid)
}

// -------------------------------------------------------------------

// A2UResponses

// repeated .AGoodInfo goodReady = 1;
inline int A2UResponses::goodready_size() const {
  return goodready_.size();
}
inline void A2UResponses::clear_goodready() {
  goodready_.Clear();
}
inline const ::AGoodInfo& A2UResponses::goodready(int index) const {
  // @@protoc_insertion_point(field_get:A2UResponses.goodReady)
  return goodready_.Get(index);
}
inline ::AGoodInfo* A2UResponses::mutable_goodready(int index) {
  // @@protoc_insertion_point(field_mutable:A2UResponses.goodReady)
  return goodready_.Mutable(index);
}
inline ::AGoodInfo* A2UResponses::add_goodready() {
  // @@protoc_insertion_point(field_add:A2UResponses.goodReady)
  return goodready_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::AGoodInfo >*
A2UResponses::mutable_goodready() {
  // @@protoc_insertion_point(field_mutable_list:A2UResponses.goodReady)
  return &goodready_;
}
inline const ::google::protobuf::RepeatedPtrField< ::AGoodInfo >&
A2UResponses::goodready() const {
  // @@protoc_insertion_point(field_list:A2UResponses.goodReady)
  return goodready_;
}

// repeated .UTruckInfo truckLeave = 2;
inline int A2UResponses::truckleave_size() const {
  return truckleave_.size();
}
inline void A2UResponses::clear_truckleave() {
  truckleave_.Clear();
}
inline const ::UTruckInfo& A2UResponses::truckleave(int index) const {
  // @@protoc_insertion_point(field_get:A2UResponses.truckLeave)
  return truckleave_.Get(index);
}
inline ::UTruckInfo* A2UResponses::mutable_truckleave(int index) {
  // @@protoc_insertion_point(field_mutable:A2UResponses.truckLeave)
  return truckleave_.Mutable(index);
}
inline ::UTruckInfo* A2UResponses::add_truckleave() {
  // @@protoc_insertion_point(field_add:A2UResponses.truckLeave)
  return truckleave_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::UTruckInfo >*
A2UResponses::mutable_truckleave() {
  // @@protoc_insertion_point(field_mutable_list:A2UResponses.truckLeave)
  return &truckleave_;
}
inline const ::google::protobuf::RepeatedPtrField< ::UTruckInfo >&
A2UResponses::truckleave() const {
  // @@protoc_insertion_point(field_list:A2UResponses.truckLeave)
  return truckleave_;
}

// optional string error = 3;
inline bool A2UResponses::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void A2UResponses::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void A2UResponses::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void A2UResponses::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& A2UResponses::error() const {
  // @@protoc_insertion_point(field_get:A2UResponses.error)
  return error_.GetNoArena();
}
inline void A2UResponses::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:A2UResponses.error)
}
#if LANG_CXX11
inline void A2UResponses::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:A2UResponses.error)
}
#endif
inline void A2UResponses::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:A2UResponses.error)
}
inline void A2UResponses::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:A2UResponses.error)
}
inline ::std::string* A2UResponses::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:A2UResponses.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* A2UResponses::release_error() {
  // @@protoc_insertion_point(field_release:A2UResponses.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void A2UResponses::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:A2UResponses.error)
}

// -------------------------------------------------------------------

// U2AResponses

// repeated .UTruckInfo truckArrived = 1;
inline int U2AResponses::truckarrived_size() const {
  return truckarrived_.size();
}
inline void U2AResponses::clear_truckarrived() {
  truckarrived_.Clear();
}
inline const ::UTruckInfo& U2AResponses::truckarrived(int index) const {
  // @@protoc_insertion_point(field_get:U2AResponses.truckArrived)
  return truckarrived_.Get(index);
}
inline ::UTruckInfo* U2AResponses::mutable_truckarrived(int index) {
  // @@protoc_insertion_point(field_mutable:U2AResponses.truckArrived)
  return truckarrived_.Mutable(index);
}
inline ::UTruckInfo* U2AResponses::add_truckarrived() {
  // @@protoc_insertion_point(field_add:U2AResponses.truckArrived)
  return truckarrived_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::UTruckInfo >*
U2AResponses::mutable_truckarrived() {
  // @@protoc_insertion_point(field_mutable_list:U2AResponses.truckArrived)
  return &truckarrived_;
}
inline const ::google::protobuf::RepeatedPtrField< ::UTruckInfo >&
U2AResponses::truckarrived() const {
  // @@protoc_insertion_point(field_list:U2AResponses.truckArrived)
  return truckarrived_;
}

// repeated int64 packageFinished = 2;
inline int U2AResponses::packagefinished_size() const {
  return packagefinished_.size();
}
inline void U2AResponses::clear_packagefinished() {
  packagefinished_.Clear();
}
inline ::google::protobuf::int64 U2AResponses::packagefinished(int index) const {
  // @@protoc_insertion_point(field_get:U2AResponses.packageFinished)
  return packagefinished_.Get(index);
}
inline void U2AResponses::set_packagefinished(int index, ::google::protobuf::int64 value) {
  packagefinished_.Set(index, value);
  // @@protoc_insertion_point(field_set:U2AResponses.packageFinished)
}
inline void U2AResponses::add_packagefinished(::google::protobuf::int64 value) {
  packagefinished_.Add(value);
  // @@protoc_insertion_point(field_add:U2AResponses.packageFinished)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
U2AResponses::packagefinished() const {
  // @@protoc_insertion_point(field_list:U2AResponses.packageFinished)
  return packagefinished_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
U2AResponses::mutable_packagefinished() {
  // @@protoc_insertion_point(field_mutable_list:U2AResponses.packageFinished)
  return &packagefinished_;
}

// repeated .UTruckMatch truckReady = 3;
inline int U2AResponses::truckready_size() const {
  return truckready_.size();
}
inline void U2AResponses::clear_truckready() {
  truckready_.Clear();
}
inline const ::UTruckMatch& U2AResponses::truckready(int index) const {
  // @@protoc_insertion_point(field_get:U2AResponses.truckReady)
  return truckready_.Get(index);
}
inline ::UTruckMatch* U2AResponses::mutable_truckready(int index) {
  // @@protoc_insertion_point(field_mutable:U2AResponses.truckReady)
  return truckready_.Mutable(index);
}
inline ::UTruckMatch* U2AResponses::add_truckready() {
  // @@protoc_insertion_point(field_add:U2AResponses.truckReady)
  return truckready_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::UTruckMatch >*
U2AResponses::mutable_truckready() {
  // @@protoc_insertion_point(field_mutable_list:U2AResponses.truckReady)
  return &truckready_;
}
inline const ::google::protobuf::RepeatedPtrField< ::UTruckMatch >&
U2AResponses::truckready() const {
  // @@protoc_insertion_point(field_list:U2AResponses.truckReady)
  return truckready_;
}

// optional string error = 4;
inline bool U2AResponses::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void U2AResponses::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void U2AResponses::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void U2AResponses::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& U2AResponses::error() const {
  // @@protoc_insertion_point(field_get:U2AResponses.error)
  return error_.GetNoArena();
}
inline void U2AResponses::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:U2AResponses.error)
}
#if LANG_CXX11
inline void U2AResponses::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:U2AResponses.error)
}
#endif
inline void U2AResponses::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:U2AResponses.error)
}
inline void U2AResponses::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:U2AResponses.error)
}
inline ::std::string* U2AResponses::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:U2AResponses.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* U2AResponses::release_error() {
  // @@protoc_insertion_point(field_release:U2AResponses.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void U2AResponses::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:U2AResponses.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_amazon_2eproto__INCLUDED
